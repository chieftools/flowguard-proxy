name: Build and Publish Packages

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (e.g., 1.0.0)'
        required: true
      rebuild_rpm_repo:
        description: 'Download all RPM files and rebuild repo metadata from scratch'
        type: boolean
        default: false

permissions:
  contents: write

jobs:
  build-and-publish:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: 'go.mod'

      - name: Get version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${GITHUB_REF#refs/tags/v}"
          fi
          echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "Building version: ${VERSION}"

      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y apt-utils createrepo-c rpm gpg rsync

      - name: Import GPG key
        run: |
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
          echo "${{ secrets.GPG_PASSPHRASE }}" > /tmp/gpg-passphrase

      - name: Build DEB package
        run: |
          chmod +x ./bin/build-deb.sh
          ./bin/build-deb.sh ${{ steps.version.outputs.VERSION }}

      - name: Build RPM package
        run: |
          chmod +x ./bin/build-rpm.sh
          ./bin/build-rpm.sh ${{ steps.version.outputs.VERSION }} 1

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $(echo "${{ secrets.SSH_HOST }}" | cut -d@ -f2) >> ~/.ssh/known_hosts

      - name: Download existing repository metadata
        run: |
          SSH_CMD="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no"

          # Download only DEB metadata (not the pool with all .deb archives)
          mkdir -p repo-sync/deb/dists
          rsync -avz -e "${SSH_CMD}" \
            ${{ secrets.SSH_HOST }}:${{ secrets.SSH_PATH }}/deb/dists/ repo-sync/deb/dists/ || true

          # Download RPM repository
          mkdir -p repo-sync/rpm/stable/x86_64
          if [ "${{ inputs.rebuild_rpm_repo }}" = "true" ]; then
            echo "Rebuilding RPM repo: downloading all packages..."
            rsync -avz -e "${SSH_CMD}" \
              ${{ secrets.SSH_HOST }}:${{ secrets.SSH_PATH }}/rpm/stable/x86_64/ \
              repo-sync/rpm/stable/x86_64/ || true
          else
            mkdir -p repo-sync/rpm/stable/x86_64/repodata
            rsync -avz -e "${SSH_CMD}" \
              ${{ secrets.SSH_HOST }}:${{ secrets.SSH_PATH }}/rpm/stable/x86_64/repodata/ \
              repo-sync/rpm/stable/x86_64/repodata/ || true
          fi

      - name: Update DEB repository
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          DEB_FILE="flowguard_${VERSION}_amd64.deb"
          PACKAGES_DIR="repo-sync/deb/dists/stable/main/binary-amd64"
          POOL_DIR="repo-sync/deb/pool/main/f/flowguard"

          # Place new package in pool directory structure
          mkdir -p "${POOL_DIR}"
          cp "${DEB_FILE}" "${POOL_DIR}/"

          # Generate Packages entry for the new .deb
          NEW_ENTRY=$(cd repo-sync/deb && apt-ftparchive packages pool/)

          # Prepare Packages file
          mkdir -p "${PACKAGES_DIR}"
          touch "${PACKAGES_DIR}/Packages"

          # Remove any existing entry for this version (in case of re-release)
          if [ -s "${PACKAGES_DIR}/Packages" ]; then
            awk -v RS='\n\n' -v ORS='\n\n' -v ver="flowguard_${VERSION}_amd64.deb" \
              '$0 !~ ver && NF' "${PACKAGES_DIR}/Packages" > "${PACKAGES_DIR}/Packages.tmp"
            mv "${PACKAGES_DIR}/Packages.tmp" "${PACKAGES_DIR}/Packages"
          fi

          # Append new entry
          printf '%s' "${NEW_ENTRY}" >> "${PACKAGES_DIR}/Packages"

          # Generate compressed versions
          gzip -9c "${PACKAGES_DIR}/Packages" > "${PACKAGES_DIR}/Packages.gz"
          bzip2 -9c "${PACKAGES_DIR}/Packages" > "${PACKAGES_DIR}/Packages.bz2"

          # Remove any stale files from old aptly-generated repo that we don't manage
          find repo-sync/deb/dists/ -name "*.xz" -delete 2>/dev/null || true
          find repo-sync/deb/dists/ -name "Contents-*" -delete 2>/dev/null || true

          # Generate Release file
          cd repo-sync/deb
          apt-ftparchive \
            -o APT::FTPArchive::Release::Origin="FlowGuard" \
            -o APT::FTPArchive::Release::Label="FlowGuard" \
            -o APT::FTPArchive::Release::Suite="stable" \
            -o APT::FTPArchive::Release::Codename="stable" \
            -o APT::FTPArchive::Release::Components="main" \
            -o APT::FTPArchive::Release::Architectures="amd64" \
            release dists/stable/ > dists/stable/Release

          # Sign Release file
          rm -f dists/stable/InRelease dists/stable/Release.gpg

          gpg --batch --yes --clearsign \
            --pinentry-mode loopback \
            --passphrase-file=/tmp/gpg-passphrase \
            -o dists/stable/InRelease dists/stable/Release

          gpg --batch --yes --detach-sign --armor \
            --pinentry-mode loopback \
            --passphrase-file=/tmp/gpg-passphrase \
            -o dists/stable/Release.gpg dists/stable/Release

          cd ../..

      - name: Setup RPM repository
        run: |
          RPM_FILE="flowguard-${{ steps.version.outputs.VERSION }}-1.x86_64.rpm"
          REPO_DIR="repo-sync/rpm/stable/x86_64"

          # Sign the RPM
          echo "%_gpg_name FlowGuard Team <hello@flowguard.network>" > ~/.rpmmacros
          echo "%_signature gpg" >> ~/.rpmmacros
          echo "%_gpg_path $HOME/.gnupg" >> ~/.rpmmacros

          rpm --addsign --define "_gpg_name FlowGuard Team <hello@flowguard.network>" \
            "${RPM_FILE}" || echo "RPM signing failed, continuing..."

          # Copy new RPM to repo directory
          mkdir -p "${REPO_DIR}"
          cp "${RPM_FILE}" "${REPO_DIR}/"

          if [ "${{ inputs.rebuild_rpm_repo }}" = "true" ]; then
            # Full rebuild: all RPM files are present, generate fresh metadata
            createrepo_c "${REPO_DIR}"
          else
            # Incremental: create placeholders for old RPMs so createrepo_c --update
            # preserves their metadata without needing the actual files
            OLD_PRIMARY=$(find "${REPO_DIR}/repodata" -name "*-primary.xml.gz" 2>/dev/null | head -1)
            if [ -n "${OLD_PRIMARY}" ]; then
              gunzip -c "${OLD_PRIMARY}" | grep -oP 'href="\K[^"]+' | while read -r rpm; do
                [ ! -f "${REPO_DIR}/${rpm}" ] && touch "${REPO_DIR}/${rpm}"
              done
            fi
            createrepo_c --update --skip-stat "${REPO_DIR}"
          fi

          # Sign the repository metadata
          gpg --batch --yes --detach-sign --armor \
            --pinentry-mode loopback \
            --passphrase-file=/tmp/gpg-passphrase \
            "${REPO_DIR}/repodata/repomd.xml"

          # Clean up empty placeholder files
          find "${REPO_DIR}" -maxdepth 1 -name "*.rpm" -empty -delete

      - name: Create repository configuration files
        run: |
          # Create install script for users in root
          cat > repo-sync/install.sh << 'INSTALL_EOF'
          #!/bin/bash
          set -e

          # Detect OS
          if [ -f /etc/os-release ]; then
              . /etc/os-release
              OS=$ID
          else
              echo "Cannot detect OS"
              exit 1
          fi

          case $OS in
              ubuntu|debian)
                  echo "Setting up FlowGuard repository for Debian/Ubuntu..."

                  # Add GPG key
                  curl -sS https://pkg.flowguard.network/gpg.key | gpg --dearmor --yes -o /etc/apt/trusted.gpg.d/flowguard.gpg

                  # Add repository
                  echo "deb https://pkg.flowguard.network/deb stable main" | tee /etc/apt/sources.list.d/flowguard.list

                  # Update and install
                  apt-get update
                  apt-get install -y flowguard
                  ;;

              centos|rhel|rocky|almalinux|fedora)
                  echo "Setting up FlowGuard repository for RHEL/CentOS/Rocky/Alma/Fedora..."

                  # Add repository
                  cat > /etc/yum.repos.d/flowguard.repo << 'EOF'
          [flowguard]
          name=FlowGuard Repository
          baseurl=https://pkg.flowguard.network/rpm/stable/x86_64
          enabled=1
          gpgcheck=1
          gpgkey=https://pkg.flowguard.network/gpg.key
          EOF

                  # Install
                  yum install -y flowguard || dnf install -y flowguard
                  ;;

              *)
                  echo "Unsupported OS: $OS"
                  echo "Please install manually from https://github.com/chieftools/flowguard-proxy/releases"
                  exit 1
                  ;;
          esac

          echo ""
          echo "FlowGuard installed successfully!"
          echo "Configure it at: /etc/flowguard/config.json or use setup instructions from https://flowguard.network"
          echo "Start the service: systemctl start flowguard"
          echo "Start the service on boot: systemctl enable flowguard"
          INSTALL_EOF

          chmod +x repo-sync/install.sh

          # Export GPG public key
          gpg --armor --export "FlowGuard Team <hello@flowguard.network>" > repo-sync/gpg.key

          # Copy config schema to root
          cp config.schema.json repo-sync/config.schema.json

      - name: Upload to server
        run: |
          SSH_CMD="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no"

          # Upload new .deb to pool (additive only, old packages remain on server)
          rsync -avz -e "${SSH_CMD}" \
            repo-sync/deb/pool/ ${{ secrets.SSH_HOST }}:${{ secrets.SSH_PATH }}/deb/pool/

          # Upload updated DEB metadata
          rsync -avz --delete -e "${SSH_CMD}" \
            repo-sync/deb/dists/ ${{ secrets.SSH_HOST }}:${{ secrets.SSH_PATH }}/deb/dists/

          # Upload new RPM package (additive only, old packages remain on server)
          rsync -avz -e "${SSH_CMD}" \
            "repo-sync/rpm/stable/x86_64/flowguard-${{ steps.version.outputs.VERSION }}-1.x86_64.rpm" \
            ${{ secrets.SSH_HOST }}:${{ secrets.SSH_PATH }}/rpm/stable/x86_64/

          # Upload updated RPM metadata
          rsync -avz --delete -e "${SSH_CMD}" \
            repo-sync/rpm/stable/x86_64/repodata/ \
            ${{ secrets.SSH_HOST }}:${{ secrets.SSH_PATH }}/rpm/stable/x86_64/repodata/

          # Upload root config files
          rsync -avz -e "${SSH_CMD}" \
            repo-sync/install.sh repo-sync/gpg.key repo-sync/config.schema.json \
            ${{ secrets.SSH_HOST }}:${{ secrets.SSH_PATH }}/

      - name: Clean up
        if: always()
        run: |
          rm -f /tmp/gpg-passphrase
          rm -f ~/.ssh/deploy_key
          rm -rf ~/.gnupg/private-keys-v1.d/*

      - name: Upload artifacts
        uses: actions/upload-artifact@v7
        with:
          name: packages
          path: |
            flowguard_*.deb
            flowguard-*.rpm
          retention-days: 30

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        if: startsWith(github.ref, 'refs/tags/')
        with:
          files: |
            flowguard_${{ steps.version.outputs.VERSION }}_amd64.deb
            flowguard-${{ steps.version.outputs.VERSION }}-1.x86_64.rpm
          body: |
            - Installation instructions: https://github.com/chieftools/flowguard-proxy#quick-install
            - Upgrade instructions: https://github.com/chieftools/flowguard-proxy#upgrading
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
